├─ ./
│   ├─ .env

│   # --- Begin: .env ---
DEBUG=True
SECRET_KEY=your-very-secure-secret-key

ALLOWED_HOSTS=127.0.0.1,localhost
CSRF_TRUSTED_ORIGINS=http://localhost:3000,http://127.0.0.1:3000

# Leave this True for local, False in production
CORS_ALLOW_ALL_ORIGINS=True
# CORS_ALLOWED_ORIGINS=https://yourdomain.com,https://www.yourdomain.com

DB_NAME=bankinsightdb
DB_USER=postgres
DB_PASSWORD=sushantno111
DB_HOST=localhost
DB_PORT=5432

MEDIA_ROOT=media/
BERT_MODEL_NAME=kuro-08/bert-transaction-categorization

# 🚀 For prod only
# DEBUG=False
# ALLOWED_HOSTS=yourdomain.com
# CORS_ALLOW_ALL_ORIGINS=False
# CORS_ALLOWED_ORIGINS=https://yourdomain.com
# SESSION_COOKIE_SECURE=True
# CSRF_COOKIE_SECURE=True

│   # --- End: .env ---

│   ├─ export_project_structure.py

│   # --- Begin: export_project_structure.py ---
import os

def dump_project_to_txt(root_dir, output_file):
    with open(output_file, "w", encoding="utf-8") as f:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            level = dirpath.replace(root_dir, "").count(os.sep)
            indent = "│   " * level
            f.write(f"{indent}├─ {os.path.basename(dirpath)}/\n")
            sub_indent = "│   " * (level + 1)
            for filename in filenames:
                f.write(f"{sub_indent}├─ {filename}\n")
                full_path = os.path.join(dirpath, filename)
                if filename.endswith((".py", ".env", ".txt", ".json")):
                    try:
                        with open(full_path, "r", encoding="utf-8") as code_file:
                            code = code_file.read()
                            f.write(f"\n{sub_indent}# --- Begin: {filename} ---\n")
                            f.write(code + "\n")
                            f.write(f"{sub_indent}# --- End: {filename} ---\n\n")
                    except Exception as e:
                        f.write(f"{sub_indent}[Could not read {filename}: {e}]\n")

dump_project_to_txt(".", "project_dump.txt")

│   # --- End: export_project_structure.py ---

│   ├─ manage.py

│   # --- Begin: manage.py ---
#!/usr/bin/env python
import os
import sys
import logging

logging.basicConfig(level=logging.DEBUG)
print("⚠ manage.py is running")

def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'bankinsight_backend.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)

if __name__ == '__main__':
    main()

│   # --- End: manage.py ---

│   ├─ project_dump.txt

│   # --- Begin: project_dump.txt ---

│   # --- End: project_dump.txt ---

│   ├─ README.md
│   ├─ requirements.txt

│   # --- Begin: requirements.txt ---
Django>=4.2
djangorestframework>=3.14
psycopg2-binary>=2.9
pdfplumber>=0.10.2
pytesseract>=0.3.10
python-dotenv>=1.0.0
transformers>=4.41.1
torch>=2.3.0
Pillow>=10.3.0
django-cors-headers>=4.3.1
djangorestframework-simplejwt>=5.3.1

│   # --- End: requirements.txt ---

│   ├─ bankinsight_backend/
│   │   ├─ settings.py

│   │   # --- Begin: settings.py ---
from dotenv import load_dotenv
import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
dotenv_path = BASE_DIR / ".env"
load_dotenv(dotenv_path=dotenv_path)

SECRET_KEY = os.getenv("SECRET_KEY")
DEBUG = os.getenv("DEBUG", "False") == "True"
ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "").split(",")

from datetime import timedelta

SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(hours=1),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=7),
}
# ✅ CSRF setup for frontend access (adjust on deployment)
CSRF_TRUSTED_ORIGINS = os.getenv("CSRF_TRUSTED_ORIGINS", "").split(",")

# ✅ CORS configuration
CORS_ALLOW_ALL_ORIGINS = os.getenv("CORS_ALLOW_ALL_ORIGINS", "True") == "True"
# Uncomment below for deployment if CORS_ALLOW_ALL_ORIGINS=False
# CORS_ALLOWED_ORIGINS = os.getenv("CORS_ALLOWED_ORIGINS", "").split(",")

# 🚀 PRODUCTION ONLY — Secure cookies over HTTPS
# SESSION_COOKIE_SECURE = True
# CSRF_COOKIE_SECURE = True

# 🚀 PRODUCTION ONLY — Disable CORS for all origins
# CORS_ALLOW_ALL_ORIGINS = False
# CORS_ALLOWED_ORIGINS = os.getenv("CORS_ALLOWED_ORIGINS", "").split(",")

# 🚀 PRODUCTION ONLY — Turn off debug mode
# DEBUG=False

# 🚀 PRODUCTION ONLY — Set allowed hosts
# ALLOWED_HOSTS = ["yourdomain.com", "api.yourdomain.com"]

# 🚀 PRODUCTION ONLY — API Rate Limits
# REST_FRAMEWORK.update({
#     "DEFAULT_THROTTLE_CLASSES": [
#         "rest_framework.throttling.UserRateThrottle",
#         "rest_framework.throttling.AnonRateThrottle",
#     ],
#     "DEFAULT_THROTTLE_RATES": {
#         "user": "1000/day",
#         "anon": "100/day"
#     }
# })

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    
    "rest_framework",
    "corsheaders",
    "core",
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
]

ROOT_URLCONF = "bankinsight_backend.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "bankinsight_backend.wsgi.application"

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": os.getenv("DB_NAME"),
        "USER": os.getenv("DB_USER"),
        "PASSWORD": os.getenv("DB_PASSWORD"),
        "HOST": os.getenv("DB_HOST"),
        "PORT": os.getenv("DB_PORT"),
    }
}

AUTH_USER_MODEL = "core.User"

LANGUAGE_CODE = "en-us"
TIME_ZONE = "Asia/Kolkata"
USE_I18N = True
USE_TZ = True

STATIC_URL = "/static/"
STATIC_ROOT = os.path.join(BASE_DIR, "static/")

MEDIA_URL = "/media/"
MEDIA_ROOT = os.path.join(BASE_DIR, os.getenv("MEDIA_ROOT", "media/"))

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",
    ],
}

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# ✅ Recommended for production only (commented for local dev)
# SESSION_COOKIE_SECURE = True
# CSRF_COOKIE_SECURE = True

│   │   # --- End: settings.py ---

│   │   ├─ urls.py

│   │   # --- Begin: urls.py ---
# Root URL configuration
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path("api/", include("core.urls")),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

│   │   # --- End: urls.py ---

│   │   ├─ wsgi.py

│   │   # --- Begin: wsgi.py ---
# WSGI config for bankinsight_backend project
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'bankinsight_backend.settings')

application = get_wsgi_application()

│   │   # --- End: wsgi.py ---

│   │   ├─ __init__.py

│   │   # --- Begin: __init__.py ---

│   │   # --- End: __init__.py ---

│   │   ├─ __pycache__/
│   │   │   ├─ settings.cpython-311.pyc
│   │   │   ├─ urls.cpython-311.pyc
│   │   │   ├─ wsgi.cpython-311.pyc
│   │   │   ├─ __init__.cpython-311.pyc
│   ├─ core/
│   │   ├─ urls.py

│   │   # --- Begin: urls.py ---
# App-specific routes
from django.urls import path
from core.views.auth_views import RegisterView, LoginView
from core.views.insight_views import UserTransactionListView
from core.views.upload_views import StatementUploadView
from core.views.upload_views import ReprocessStatementView
from core.views.insight_views import FinancialInsightsView

from core.views.insight_views import ExportAllTransactionsCSV
from core.views.upload_views import ExportStatementZIP
urlpatterns = [
    path("auth/register/", RegisterView.as_view(), name="register"),
    path("auth/login/", LoginView.as_view(), name="login"),
    path("upload/statement/", StatementUploadView.as_view(), name="upload_statement"),
    path("insights/", FinancialInsightsView.as_view(), name="financial_insights"),
    path("transactions/", UserTransactionListView.as_view(), name="user_transactions"),
    path("reprocess_statement/<int:statement_id>/", ReprocessStatementView.as_view(), name="reprocess_statement"),
    path("download/transactions/", ExportAllTransactionsCSV.as_view(), name="export_all_csv"),
    path("download/statement/<int:statement_id>/", ExportStatementZIP.as_view(), name="export_statement_zip"),
]

│   │   # --- End: urls.py ---

│   │   ├─ migrations/
│   │   │   ├─ 0001_initial.py

│   │   │   # --- Begin: 0001_initial.py ---
# Generated by Django 5.2.3 on 2025-06-13 08:11

import django.db.models.deletion
import django.utils.timezone
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('email', models.EmailField(max_length=255, unique=True)),
                ('full_name', models.CharField(max_length=100)),
                ('is_active', models.BooleanField(default=True)),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'User',
                'verbose_name_plural': 'Users',
            },
        ),
        migrations.CreateModel(
            name='Statement',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('uploaded_file', models.FileField(upload_to='statements/')),
                ('uploaded_at', models.DateTimeField(default=django.utils.timezone.now)),
                ('raw_text', models.TextField(blank=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='statements', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='Transaction',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date', models.DateField()),
                ('description', models.TextField()),
                ('amount', models.DecimalField(decimal_places=2, max_digits=12)),
                ('category', models.CharField(max_length=100)),
                ('is_credit', models.BooleanField(default=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('statement', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='transactions', to='core.statement')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='transactions', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]

│   │   │   # --- End: 0001_initial.py ---

│   │   │   ├─ __init__.py

│   │   │   # --- Begin: __init__.py ---

│   │   │   # --- End: __init__.py ---

│   │   │   ├─ __pycache__/
│   │   │   │   ├─ 0001_initial.cpython-311.pyc
│   │   │   │   ├─ __init__.cpython-311.pyc
│   │   ├─ models/
│   │   │   ├─ statement.py

│   │   │   # --- Begin: statement.py ---
# PDF metadata model
from django.db import models
from core.models import User
from django.utils import timezone


class Statement(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="statements")
    uploaded_file = models.FileField(upload_to="statements/")
    uploaded_at = models.DateTimeField(default=timezone.now)
    raw_text = models.TextField(blank=True)  # OCR output

    def __str__(self):
        return f"Statement {self.id} by {self.user.email}"

│   │   │   # --- End: statement.py ---

│   │   │   ├─ transaction.py

│   │   │   # --- Begin: transaction.py ---
# Transaction model
from django.db import models
from core.models import User, Statement


class Transaction(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="transactions")
    statement = models.ForeignKey(Statement, on_delete=models.CASCADE, related_name="transactions")
    
    date = models.DateField()
    description = models.TextField()
    amount = models.DecimalField(max_digits=12, decimal_places=2)
    category = models.CharField(max_length=100)
    is_credit = models.BooleanField(default=False)

    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.date} - {self.amount} - {self.category}"

│   │   │   # --- End: transaction.py ---

│   │   │   ├─ user.py

│   │   │   # --- Begin: user.py ---
# Custom User model implementation
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager
from django.db import models
from django.utils import timezone


class UserManager(BaseUserManager):
    def create_user(self, email, password=None, **extra_fields):
        if not email:
            raise ValueError("The Email field must be set")
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    # ✅ Replace create_superuser with this:
    def create_superuser(self, email, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        if not password:
            raise ValueError("Superusers must have a password.")
        return self.create_user(email, password, **extra_fields)

class User(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(unique=True, max_length=255)
    full_name = models.CharField(max_length=100)
    is_active = models.BooleanField(default=True)
    date_joined = models.DateTimeField(default=timezone.now)

    objects = UserManager()

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = ["full_name"]

    def __str__(self):
        return self.email

    class Meta:
        verbose_name = "User"
        verbose_name_plural = "Users"

│   │   │   # --- End: user.py ---

│   │   │   ├─ __init__.py

│   │   │   # --- Begin: __init__.py ---
from .user import User
from .statement import Statement
from .transaction import Transaction

__all__ = ["User", "Statement", "Transaction"]

│   │   │   # --- End: __init__.py ---

│   │   │   ├─ __pycache__/
│   │   │   │   ├─ statement.cpython-311.pyc
│   │   │   │   ├─ transaction.cpython-311.pyc
│   │   │   │   ├─ user.cpython-311.pyc
│   │   │   │   ├─ __init__.cpython-311.pyc
│   │   ├─ serializers/
│   │   │   ├─ insight_serializer.py

│   │   │   # --- Begin: insight_serializer.py ---
# Insight model serializer
from rest_framework import serializers

class CategoryBreakdownSerializer(serializers.Serializer):
    category = serializers.CharField()
    total_spent = serializers.DecimalField(max_digits=12, decimal_places=2)

class MonthlyTrendSerializer(serializers.Serializer):
    month = serializers.CharField()
    total_spent = serializers.DecimalField(max_digits=12, decimal_places=2)

class TopMerchantSerializer(serializers.Serializer):
    merchant = serializers.CharField()
    amount = serializers.DecimalField(max_digits=12, decimal_places=2)

class RecurringExpenseSerializer(serializers.Serializer):
    description = serializers.CharField()
    monthly_average = serializers.DecimalField(max_digits=12, decimal_places=2)

class SmartSuggestionSerializer(serializers.Serializer):
    suggestion = serializers.CharField()

│   │   │   # --- End: insight_serializer.py ---

│   │   │   ├─ statement_serializer.py

│   │   │   # --- Begin: statement_serializer.py ---
# Statement model serializer
from rest_framework import serializers
from core.models.statement import Statement


class StatementUploadSerializer(serializers.ModelSerializer):
    class Meta:
        model = Statement
        fields = ["id", "uploaded_file", "uploaded_at", "raw_text"]
        read_only_fields = ["id", "uploaded_at", "raw_text"]

│   │   │   # --- End: statement_serializer.py ---

│   │   │   ├─ transaction_serializer.py

│   │   │   # --- Begin: transaction_serializer.py ---
# Transaction model serializer
from rest_framework import serializers
from core.models.transaction import Transaction


class TransactionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Transaction
        fields = "__all__"
        read_only_fields = ["id", "user", "created_at"]

│   │   │   # --- End: transaction_serializer.py ---

│   │   │   ├─ user_serializer.py

│   │   │   # --- Begin: user_serializer.py ---
# User model serializer

from rest_framework import serializers
from core.models import User
from django.contrib.auth import authenticate


class UserRegisterSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, min_length=6)

    class Meta:
        model = User
        fields = ["email", "full_name", "password"]

    def create(self, validated_data):
        return User.objects.create_user(**validated_data)


class UserLoginSerializer(serializers.Serializer):
    email = serializers.EmailField()
    password = serializers.CharField(write_only=True)

    def validate(self, data):
        user = authenticate(email=data["email"], password=data["password"])
        if not user:
            raise serializers.ValidationError("Invalid credentials.")
        data["user"] = user
        return data

│   │   │   # --- End: user_serializer.py ---

│   │   │   ├─ __init__.py

│   │   │   # --- Begin: __init__.py ---
from .user_serializer import *
from .statement_serializer import *
from .transaction_serializer import *
from .insight_serializer import *

│   │   │   # --- End: __init__.py ---

│   │   │   ├─ __pycache__/
│   │   │   │   ├─ insight_serializer.cpython-311.pyc
│   │   │   │   ├─ statement_serializer.cpython-311.pyc
│   │   │   │   ├─ transaction_serializer.cpython-311.pyc
│   │   │   │   ├─ user_serializer.cpython-311.pyc
│   │   │   │   ├─ __init__.cpython-311.pyc
│   │   ├─ tasks/
│   │   │   ├─ ai_utils.py

│   │   │   # --- Begin: ai_utils.py ---
from collections import defaultdict
from datetime import datetime
from core.models.transaction import Transaction
import logging

logger = logging.getLogger(__name__)

STOP_WORDS = {"amazon", "services", "payment", "debit", "upi", "account"}

def get_categorized_expense_breakdown(user):
    result = defaultdict(float)
    for txn in Transaction.objects.filter(user=user, is_credit=False):
        result[txn.category] += float(txn.amount)
    return dict(result)

def get_monthly_trends(user):
    trends = defaultdict(float)
    for txn in Transaction.objects.filter(user=user, is_credit=False):
        key = txn.date.strftime("%Y-%m")
        trends[key] += float(txn.amount)
    return dict(trends)

def get_top_merchants(user, top_n=5):
    merchant_count = defaultdict(int)
    for txn in Transaction.objects.filter(user=user):
        words = txn.description.lower().split()
        for w in words:
            if w.isalpha() and len(w) > 3 and w not in STOP_WORDS:
                merchant_count[w] += 1
    sorted_merchants = sorted(merchant_count.items(), key=lambda x: x[1], reverse=True)
    return sorted_merchants[:top_n]

def get_recurring_expenses(user):
    raw_txns = Transaction.objects.filter(user=user, is_credit=False)
    grouped = defaultdict(list)
    for txn in raw_txns:
        grouped[txn.description.lower()].append(float(txn.amount))

    recurring = {}
    for desc, amounts in grouped.items():
        if len(amounts) >= 3:
            avg_amt = sum(amounts) / len(amounts)
            recurring[desc] = round(avg_amt, 2)

    return recurring

def get_savings_insights(user):
    credits = sum(txn.amount for txn in Transaction.objects.filter(user=user, is_credit=True))
    debits = sum(txn.amount for txn in Transaction.objects.filter(user=user, is_credit=False))
    savings = credits - debits
    return {
        "total_income": round(credits, 2),
        "total_expenses": round(debits, 2),
        "estimated_savings": round(savings, 2),
        "suggestion": "Reduce dining or subscriptions if low on savings." if savings < (0.1 * credits) else "You're saving well!"
    }

│   │   │   # --- End: ai_utils.py ---

│   │   │   ├─ ocr.py

│   │   │   # --- Begin: ocr.py ---
# pdfplumber + pytesseract implementation
import pdfplumber
import pytesseract
from pdf2image import convert_from_path
from pathlib import Path
import logging
logger = logging.getLogger(__name__)

# Optional: Set Tesseract path if needed (Windows)
pytesseract.pytesseract.tesseract_cmd = r"C:\Program Files\Tesseract-OCR\tesseract.exe"


def extract_text_from_pdf(file_path: str) -> str:
    try:
        full_text = ""

        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text = page.extract_text()
                if text:
                    full_text += text + "\n"

        if full_text.strip():
            return full_text

        # If text-based OCR fails, use image OCR
        images = convert_from_path(file_path)
        for image in images:
            full_text += pytesseract.image_to_string(image)

        return full_text.strip()

    except Exception as e:
        logger.error(f"OCR failed for {file_path}: {str(e)}")
        return "[OCR Failed]"
│   │   │   # --- End: ocr.py ---

│   │   │   ├─ preprocess.py

│   │   │   # --- Begin: preprocess.py ---
import re
from datetime import datetime
from transformers import pipeline
from core.models.transaction import Transaction
from core.models.statement import Statement
import logging

logger = logging.getLogger(__name__)

# 🧠 Load the BERT model for transaction categorization
try:
    bert_model = pipeline(
        "text-classification",
        model="kuro-08/bert-transaction-categorization",
        tokenizer="kuro-08/bert-transaction-categorization"
    )
except Exception as e:
    bert_model = None
    logger.warning(f"BERT model load failed: {e}")

# 🧠 Support multiple transaction formats with flexible patterns
REGEX_PATTERNS = [
    {
        "pattern": re.compile(
            r"(?P<date>\d{2}/\d{2}/\d{4})\s+(?P<desc>.+?)\s+(?P<amount>[\d,]+\.\d{2})\s+(?P<type>CR|DR)"
        ),
        "date_format": "%d/%m/%Y",
        "has_crdr": True
    },
    {
        "pattern": re.compile(
            r"(?P<date>\d{2}-\d{2}-\d{4})\s+(?P<desc>[A-Za-z\s]+)\s+\d+\s+Rs\s(?P<amount>[\d,]+\.\d{2})"
        ),
        "date_format": "%d-%m-%Y",
        "has_crdr": False
    },
    {
        "pattern": re.compile(
            r"(?P<date>\d{4}-\d{2}-\d{2})\s+(?P<desc>.+?)\s+(?P<amount>[\d,]+\.\d{2})"
        ),
        "date_format": "%Y-%m-%d",
        "has_crdr": False
    },
    # Add more patterns here...
]

def extract_transactions(raw_text):
    """
    Try all known patterns and extract transactions intelligently.
    """
    for parser in REGEX_PATTERNS:
        pattern = parser["pattern"]
        has_crdr = parser["has_crdr"]
        date_format = parser["date_format"]
        matches = list(pattern.finditer(raw_text))

        if not matches:
            continue  # Try next pattern

        logger.info(f"Matched {len(matches)} transactions using format: {date_format}")
        transactions = []

        for match in matches:
            try:
                date_str = match.group("date").strip()
                description = match.group("desc").strip()
                amount_str = match.group("amount").replace(",", "").strip()
                amount = float(amount_str)
                txn_date = datetime.strptime(date_str, date_format).date()

                if has_crdr:
                    txn_type = match.group("type").strip().upper()
                    is_credit = txn_type == "CR"
                else:
                    is_credit = False  # fallback for unsupported formats

                transactions.append({
                    "date": txn_date,
                    "description": description,
                    "amount": amount,
                    "is_credit": is_credit
                })
            except Exception as e:
                logger.warning(f"Transaction parse error: {e} in line: {match.group(0)}")

        if transactions:
            return transactions

    logger.warning("❌ No matching regex patterns found for transaction extraction.")
    return []


def categorize_transaction(description):
    """
    Categorize a transaction using BERT or return 'Uncategorized'.
    """
    if not bert_model:
        return "Uncategorized"

    try:
        result = bert_model(description[:256])[0]
        return result["label"]
    except Exception as e:
        logger.warning(f"Categorization failed for '{description}': {e}")
        return "Uncategorized"


def process_and_store_transactions(user, statement):
    """
    Extract, categorize, and store transactions from raw OCR text.
    """
    transactions = extract_transactions(statement.raw_text)
    logger.info(f"Processing {len(transactions)} transactions for user {user.email}")

    for txn in transactions:
        category = categorize_transaction(txn["description"])
        Transaction.objects.create(
            user=user,
            statement=statement,
            date=txn["date"],
            description=txn["description"],
            amount=txn["amount"],
            is_credit=txn["is_credit"],
            category=category
        )

    return len(transactions)

│   │   │   # --- End: preprocess.py ---

│   │   │   ├─ __init__.py

│   │   │   # --- Begin: __init__.py ---
from .ocr import *
from .preprocess import *
from .ai_utils import *

│   │   │   # --- End: __init__.py ---

│   │   │   ├─ __pycache__/
│   │   │   │   ├─ ai_utils.cpython-311.pyc
│   │   │   │   ├─ ocr.cpython-311.pyc
│   │   │   │   ├─ preprocess.cpython-311.pyc
│   │   │   │   ├─ __init__.cpython-311.pyc
│   │   ├─ utils/
│   │   │   ├─ auth.py

│   │   │   # --- Begin: auth.py ---
# JWT/session authentication logic
# Placeholder — Add custom logic here later, if needed (e.g., token decoding, custom claims, etc.)
# utils/auth.py
# TODO: Add custom JWT decoding or claims logic here if needed
│   │   │   # --- End: auth.py ---

│   │   │   ├─ helpers.py

│   │   │   # --- Begin: helpers.py ---
# Utility functions
# TODO: Add reusable helper functions (e.g., date formatting, number utils)
│   │   │   # --- End: helpers.py ---

│   │   │   ├─ __init__.py

│   │   │   # --- Begin: __init__.py ---
from .auth import *
from .helpers import *

│   │   │   # --- End: __init__.py ---

│   │   ├─ views/
│   │   │   ├─ auth_views.py

│   │   │   # --- Begin: auth_views.py ---
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework_simplejwt.tokens import RefreshToken
from core.serializers.user_serializer import UserRegisterSerializer, UserLoginSerializer
import logging
from rest_framework.permissions import AllowAny

logger = logging.getLogger(__name__)

def get_tokens_for_user(user):
    refresh = RefreshToken.for_user(user)
    return {
        "refresh": str(refresh),
        "access": str(refresh.access_token),
    }

class RegisterView(APIView):
    permission_classes = [AllowAny]
    def post(self, request):
        serializer = UserRegisterSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.save()
            tokens = get_tokens_for_user(user)
            logger.info(f"User registered: {user.email}")
            return Response({"user": serializer.data, "tokens": tokens}, status=status.HTTP_201_CREATED)
        logger.warning(f"Registration failed: {serializer.errors}")
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class LoginView(APIView):
    permission_classes = [AllowAny]
    def post(self, request):
        serializer = UserLoginSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.validated_data["user"]
            tokens = get_tokens_for_user(user)
            logger.info(f"User logged in: {user.email}")
            return Response({"tokens": tokens, "email": user.email}, status=status.HTTP_200_OK)
        logger.warning(f"Login failed: {serializer.errors}")
        return Response(serializer.errors, status=status.HTTP_401_UNAUTHORIZED)

│   │   │   # --- End: auth_views.py ---

│   │   │   ├─ insight_views.py

│   │   │   # --- Begin: insight_views.py ---
# insightsview.py

from rest_framework import generics, filters, status
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.http import HttpResponse
from django_filters.rest_framework import DjangoFilterBackend
import csv, logging
from io import StringIO
from core.models.transaction import Transaction
from core.serializers.transaction_serializer import TransactionSerializer
from core.tasks.ai_utils import (
    get_categorized_expense_breakdown,
    get_monthly_trends,
    get_top_merchants,
    get_recurring_expenses,
    get_savings_insights,
)

logger = logging.getLogger(__name__)

class FinancialInsightsView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        try:
            data = {
                "categorized_expenses": get_categorized_expense_breakdown(user),
                "monthly_trends": get_monthly_trends(user),
                "top_merchants": get_top_merchants(user),
                "recurring_expenses": get_recurring_expenses(user),
                "savings_summary": get_savings_insights(user)
            }
            return Response(data, status=status.HTTP_200_OK)
        except Exception as e:
            logger.error(f"Insight generation failed: {e}")
            return Response({"error": "Failed to generate insights"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class UserTransactionListView(generics.ListAPIView):
    serializer_class = TransactionSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend, filters.OrderingFilter, filters.SearchFilter]
    filterset_fields = ['category', 'is_credit']
    search_fields = ['description']
    ordering_fields = ['date', 'amount']

    def get_queryset(self):
        user = self.request.user
        month = self.request.query_params.get('month')
        queryset = Transaction.objects.filter(user=user)

        if month:
            try:
                year, month = map(int, month.split('-'))
                queryset = queryset.filter(date__year=year, date__month=month)
            except ValueError:
                logger.warning("Invalid month format")
        return queryset


class ExportAllTransactionsCSV(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        try:
            transactions = Transaction.objects.filter(user=user)
            response = HttpResponse(content_type='text/csv')
            response['Content-Disposition'] = 'attachment; filename="all_transactions.csv"'

            writer = csv.writer(response)
            writer.writerow(['Date', 'Description', 'Amount', 'Category', 'Credit/Debit'])

            for txn in transactions:
                writer.writerow([
                    txn.date.strftime('%Y-%m-%d'),
                    txn.description,
                    txn.amount,
                    txn.category,
                    'Credit' if txn.is_credit else 'Debit'
                ])
            return response
        except Exception as e:
            logger.error(f"CSV export failed: {e}")
            return Response({"error": "Failed to export CSV"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


│   │   │   # --- End: insight_views.py ---

│   │   │   ├─ upload_views.py

│   │   │   # --- Begin: upload_views.py ---
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.parsers import MultiPartParser
from rest_framework import status, permissions
from django.http import HttpResponse
import logging

from core.serializers.statement_serializer import StatementUploadSerializer
from core.tasks.ocr import extract_text_from_pdf
from core.tasks.preprocess import process_and_store_transactions
from core.models.statement import Statement
from core.models.transaction import Transaction

logger = logging.getLogger(__name__)

class StatementUploadView(APIView):
    parser_classes = [MultiPartParser]
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request):
        serializer = StatementUploadSerializer(data=request.data)
        if serializer.is_valid():
            statement = serializer.save(user=request.user)
            try:
                file_path = statement.uploaded_file.path
                raw_text = extract_text_from_pdf(file_path)
                statement.raw_text = raw_text
                statement.save()

                txn_count = process_and_store_transactions(user=request.user, statement=statement)
                logger.info(f"Uploaded and processed {txn_count} transactions for user {request.user.email}")
                return Response({
                    "message": "PDF uploaded and processed successfully.",
                    "statement_id": statement.id,
                    "raw_text_snippet": raw_text[:300] + "..." if raw_text else "",
                }, status=status.HTTP_201_CREATED)
            except Exception as e:
                logger.error(f"Statement processing failed: {e}")
                return Response({"error": "Failed to process statement."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        logger.warning(f"Invalid statement upload: {serializer.errors}")
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class ReprocessStatementView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, statement_id):
        try:
            statement = Statement.objects.get(id=statement_id, user=request.user)
        except Statement.DoesNotExist:
            return Response({"error": "Statement not found."}, status=status.HTTP_404_NOT_FOUND)

        try:
            # Delete old transactions
            Transaction.objects.filter(statement=statement).delete()

            file_path = statement.uploaded_file.path
            raw_text = extract_text_from_pdf(file_path)
            statement.raw_text = raw_text
            statement.save()

            txn_count = process_and_store_transactions(request.user, statement)
            logger.info(f"Reprocessed statement {statement_id} with {txn_count} transactions for user {request.user.email}")
            return Response({"message": f"Reprocessed successfully. {txn_count} transactions added."})
        except Exception as e:
            logger.error(f"Reprocessing failed: {e}")
            return Response({"error": "Failed to reprocess statement."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

import csv, zipfile
from io import BytesIO, StringIO
from django.http import HttpResponse
from core.models.transaction import Transaction, Statement
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated


class ExportStatementZIP(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, statement_id):
        try:
            statement = Statement.objects.get(id=statement_id, user=request.user)
        except Statement.DoesNotExist:
            return HttpResponse("Statement not found.", status=404)

        transactions = Transaction.objects.filter(statement=statement)

        # Create in-memory ZIP file
        zip_buffer = BytesIO()
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            # 1. CSV File
            csv_buffer = StringIO()
            writer = csv.writer(csv_buffer)
            writer.writerow(['Date', 'Description', 'Amount', 'Category', 'Credit/Debit'])

            for txn in transactions:
                writer.writerow([
                    txn.date.strftime('%Y-%m-%d'),
                    txn.description,
                    txn.amount,
                    txn.category,
                    'Credit' if txn.is_credit else 'Debit'
                ])

            zip_file.writestr("transactions.csv", csv_buffer.getvalue())

            # 2. OCR Text
            zip_file.writestr("raw_ocr.txt", statement.raw_text or "No text extracted.")

        zip_buffer.seek(0)
        response = HttpResponse(zip_buffer, content_type='application/zip')
        response['Content-Disposition'] = f'attachment; filename=statement_{statement.id}.zip'
        return response

│   │   │   # --- End: upload_views.py ---

│   │   │   ├─ __init__.py

│   │   │   # --- Begin: __init__.py ---
from .auth_views import *
from .upload_views import *
from .insight_views import *

│   │   │   # --- End: __init__.py ---

│   │   │   ├─ __pycache__/
│   │   │   │   ├─ auth_views.cpython-311.pyc
│   │   │   │   ├─ insight_views.cpython-311.pyc
│   │   │   │   ├─ upload_views.cpython-311.pyc
│   │   │   │   ├─ __init__.cpython-311.pyc
│   │   ├─ __pycache__/
│   │   │   ├─ urls.cpython-311.pyc
│   ├─ media/
│   │   ├─ statements/
│   │   │   ├─ sample_bank_statement.pdf
│   │   │   ├─ sample_bank_statement_erFPHqQ.pdf
│   │   │   ├─ sample_bank_statement_yZcGpcs.pdf
